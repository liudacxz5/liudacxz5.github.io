---
title: 算法基础知识
date: 2024-06-26 18:00:00
updated: 2024-06-26 18:00:00
tags: 
 - 算法
categories: 
 - 算法
keywords: 
 - 算法
description: 简述了算法的基础知识，包含算法复杂度、进制计算、位运算、原码反码补码等
top_img: 
comments: true
cover:
highlight_shrink: true
---
## 计算机上的一维坐标系：
以某一坐标点为原点，向某个方向为正方向，以一定的标度建立坐标轴即为一维坐标系
关键词：原点、方向、坐标轴
## 计算机上的二维坐标系：
二维坐标系的X轴是向下的（xy轴方向为第四象限方向）
## 方向向量：
四方向：
	-------------------------------
	|         | (x-1,y) |         |
	-------------------------------
	| (x,y-1) |  (x,y)  | (x,y+1) |
	-------------------------------
	|         | (x+1,y) |         |
	-------------------------------
八方向：
	-------------------------------
	|(x-1,y-1)| (x-1,y) |(x-1,y+1)|
	-------------------------------
	| (x,y-1) |  (x,y)  | (x,y+1) |
	-------------------------------
	|(x+1,y-1)| (x+1,y) |(x+1,y+1)|
	-------------------------------

## 算法复杂度：
### 时间复杂度：执行算法需要的工作量
1.频度：一个语句在代码中执行的次数
2.f(n)：代码中最深层次运算的频度
3.T(n)：代码中所有语句频度的和,是时间复杂度主要分析的东西 
其中算法最深层次语句执行的频度（f(n)）是与T(n)同一数量级
4.BigO（时间复杂度 O）：T(n) = O(f(n)) 简化为T(n)=O(n)
5.最坏时间复杂度：最坏情况下执行算法的时间复杂度，最多次
6.最好时间复杂度：最好情况下执行算法的时间复杂度，最少次
7.平均时间复杂度：所有可能输入的示例概率相等情况下的期望值
8.分析原则：
加法规则：T(n) = O(max(f(n),g(n))) 个人理解：同级情况下取最坏时间复杂度
乘法规则：T(n) = O(f(n)*g(n)) 个人理解：嵌套复杂度直接相乘
9.常见时间复杂度：
O(1)<O(logn)<O(n)<O(nlogn)<O(n^2)<O(n^3)<O(2^n)<O(n!)<O(n*n) 
### 空间复杂度：执行算法需要的内存空间
S(n)=O(f(n)) 

## 进制：
1.权：十进制的权 10^(N-1)
2.按权展开：将R进制数的每一位数值用ak*R^k
	
3.二进制和十进制转换：
按权展开求和：
			1 0 1 1 = 1*2^3 + 0*2^2 + 1*2^1 + 1*2^0 = 8 + 0 + 2 + 1 = 11 
			8 4 2 1
	4.十进制转二进制：
		整数部分：除2取余，倒序排列
		125 => 1111101
		 125%2=62...1
		  62%2=31...0
		  31%2=15...1
		  15%2= 7...1
		   7%2= 3...1
		   3%2= 1...1
		   1%2= 0...1
		小数部分：乘二取整，先左后右
			小数乘二取整数部分，按照先后顺序从左到右排列
	5.二进制转八进制（前面补零）：
		从后往前三位一割不足补零
		11 = 011 = 3
	6.八进制转二进制：
		八进制的每一位数字转化为对应三位二进制的数字并排列
		123 = 1010011
	7.二进制转十六进制（前面补零）：
		从后往前四位一割不足补零
		11 = 0011 = 3
	8.十六进制转二进制：
		十六进制的每一位数字转化为对应四位二进制的数字并排列
		123 = 100100011
	9.不同进制转换：本质是确定不同权值位置的上的数码
		a进制转为b进制：正整数a % a进制下b进制的数字 余数一定是0~b-1 
		                "除2取余，倒序排列"本质上就是这个

## 位运算：
### 与运算 & and
    用途：常用于二进制取位操作
    法则：两个数字与运算时相同二进制位数只有均为1的情况下结果为1否则都是0，一个数 and 1 就是取二级制最末位
        例如：100 & 111 = 100
### 或运算 | or
    用途：通常用于二进制位数上的无条件赋值
    法则：两个数字或运算时相同二进制位数只要有1的情况下结果都为1，一个数 and 1 就是强制将该数字变为最接近的偶数，一个数 or 0 不变
        例如：100 | 111 = 111
### 异或运算 ^ xor （无进位加法）
    用途：
    法则：两个数字异或运算时相同二进制位数不同为1 相同为0(相同位数两数求和大于1不进位)，一个数异或运算两次结果不变
        例如：100 ^ 111 = 011
### 非运算 ~ not
    用途：
    法则：将一个数字二进制的0和1全部取反
### 右移运算 >> shr
	用途：a>>1 就是a除以2
	法则：a>>b 即为二级制数右移b位,相当于a/(2^b)取整
### 左移运算 << shl
	用途：a<<1 就是a*2
	法则：a<<b 即为二级制数左移b位,新的位用0代替,相当于a*(2^b)。如果溢出就舍弃高位，如果舍弃的高位是1，那么a*2不成立。
### 反码补码和原码
    1.原码：最高位表示该数字符号位 1为负号 0为正号 其他位存放该数字二级制绝对值。
      原码中有-0的概念(因为最高位强制为位数)。
      原码最大的缺陷就是一个数和它的相反数相加不等于0
        例如： 1001 表示 -1   0001 表示 1
    2.反码：正数的反码是它本身，负数的反码是除了符号位以外的按位取反
        例如：3的原码是0011 则3的反码是0011 
            -3的反码是1011 则-3的反码是 1100
    3.补码：从低位到高位第一个1和它右边的0不变左边取反，符号位不变 （负数的补码等于反码+1）
    	模：一个计量系统中的计数范围，时钟系统中计量范围是0~11，那么模就是12 就会出现9-2 = 9+10
    	   n位计算机的模是0~2^n-1 即为2^n 亦有 2-1 = 2+(2^n-1)
    	   在有模的计量系统中减法即可转化为 被减数加上减数的同余数 的加法，从而实现减法转为加法。
    	同余数：n的同余数 = 模-n 
    	       模=n+n的同余数
    	例子： 
    		6    - 4    => 6    + (12)  = 2
    	    0110 - 0100 => 0110 + (1100)= 10010 = 0010
    		a-b 等于 a+b的同余数的结果取较低对应位数 